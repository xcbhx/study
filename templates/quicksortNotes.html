{% extends 'base.html' %}

{% block title %}Quicksort{% endblock %}

{% block content %}
<!-- Main Title -->
<h1 class="text-3xl font-semibold mb-6">Divide & Conquer Algorithm: Quicksort</h1>
<p class="mb-6">Quicksort is a sorting algorithm and much faster than selection sort.</p>

<!-- Understanding Divide & Conquer -->
<h2 class="text-2xl font-semibold mb-4">Understanding Divide & Conquer</h2>
<p class="mb-4">Divide & Conquer algorithms are <strong>recursive</strong>. To solve a problem using this method:</p>
<ol class="list-decimal ml-8 mb-6">
  <li>Figure out the base case (the simplest possible case).</li>
  <li>Divide or decrease the problem until it becomes the base case.</li>
</ol>
<p class="mb-6">With every recursive call, the problem is reduced further.</p>

<!-- Key Notes -->
<h3 class="text-xl font-semibold mb-4">Key Notes:</h3>
<ul class="list-disc ml-8 mb-6">
  <li>Recursion keeps track of the state.</li>
  <li>When using recursion with an array, the base case is often an empty array or an array with one element.</li>
  <li>Functional programming languages like Haskell use recursion instead of loops.</li>
</ul>

<!-- Code Block for Example Function -->
<pre class="bg-gray-100 p-4 rounded-md mb-6">
sum [] = 0
sum (x:xs) = x + (sum xs)
</pre>

<!-- Exercises -->
<h3 class="text-xl font-semibold mb-4">Exercises:</h3>
<p class="mb-4">1. Write the sum function in Python:</p>
<pre class="bg-gray-100 p-4 rounded-md mb-6">
def sum(lst):
    if lst == []:
        return 0
    return lst[0] + sum(lst[1:])
</pre>

<p class="mb-4">2. Write a recursive function to count the number of items in a list:</p>
<pre class="bg-gray-100 p-4 rounded-md mb-6">
def count(lst):
    if lst == []:
        return 0
    return 1 + count(lst[1:])
</pre>

<p class="mb-4">3. Find the maximum number in a list:</p>
<pre class="bg-gray-100 p-4 rounded-md mb-6">
def max(lst):
    if len(lst) == 2:
        return lst[0] if lst[0] > lst[1] else lst[1]
    sub_max = max(lst[1:])
    return lst[0] if lst[0] > sub_max else sub_max
</pre>

<!-- Binary Search & Divide & Conquer Section -->
<h2 class="text-2xl font-semibold mb-4">Binary Search & Divide & Conquer</h2>
<p class="mb-6">Binary search is another example of a Divide & Conquer algorithm:</p>
<ul class="list-disc ml-8 mb-6">
  <li>Base case: An array with one item. If it matches the target, return it.</li>
  <li>Recursive case: Split the array, discard one half, and apply binary search to the other half.</li>
</ul>

<hr class="my-6">

<!-- Quicksort Section -->
<h2 class="text-2xl font-semibold mb-4">Quicksort</h2>
<p class="mb-6">Quicksort is a faster sorting algorithm compared to selection sort. It also uses Divide & Conquer.</p>

<h3 class="text-xl font-semibold mb-4">Example:</h3>
<pre class="bg-gray-100 p-4 rounded-md mb-6">
[33, 15, 10]
</pre>
<ul class="list-disc ml-8 mb-6">
  <li>Pick a pivot (e.g., 33).</li>
  <li>Partition the array into two sub-arrays: one with elements smaller than the pivot and one with elements greater than the pivot.</li>
</ul>
<p class="mb-6">Partition result:</p>
<pre class="bg-gray-100 p-4 rounded-md mb-6">
[15, 10] + [33] + [] = [10, 15, 33]
</pre>

<!-- Quicksort Code -->
<h3 class="text-xl font-semibold mb-4">Quicksort Code:</h3>
<pre class="bg-gray-100 p-4 rounded-md mb-6">
def quicksort(array):
    if len(array) < 2:
        return array
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot]
        greater = [i for i in array[1:] if i > pivot]
        return quicksort(less) + [pivot] + quicksort(greater)

print(quicksort([10, 5, 2, 3]))
</pre>

<hr class="my-6">

<!-- Big O Notation -->
<h2 class="text-2xl font-semibold mb-4">Big O Notation</h2>
<p class="mb-6">Quicksort speed depends on the pivot choice:</p>
<table class="min-w-full table-auto border-collapse mb-6">
  <thead>
    <tr>
      <th class="border p-2">Algorithm</th>
      <th class="border p-2">Best Case</th>
      <th class="border p-2">Worst Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="border p-2">Binary Search</td>
      <td class="border p-2">O(log n)</td>
      <td class="border p-2">-</td>
    </tr>
    <tr>
      <td class="border p-2">Simple Search</td>
      <td class="border p-2">O(n)</td>
      <td class="border p-2">-</td>
    </tr>
    <tr>
      <td class="border p-2">Quicksort</td>
      <td class="border p-2">O(n log n)</td>
      <td class="border p-2">O(nÂ²)</td>
    </tr>
  </tbody>
</table>

<h3 class="text-xl font-semibold mb-4">Comparison to Merge Sort:</h3>
<p class="mb-6">Quicksort generally has a smaller constant than Merge Sort, making it faster in practice.</p>

<hr class="my-6">

<!-- Recap Section -->
<h2 class="text-2xl font-semibold mb-4">Recap</h2>
<ul class="list-disc ml-8 mb-6">
  <li>Divide & Conquer breaks problems into smaller subproblems until the base case is reached.</li>
  <li>Quicksort is faster in practice because it typically hits the average case.</li>
  <li>The average runtime of Quicksort is O(n log n).</li>
</ul>
{% endblock %}
