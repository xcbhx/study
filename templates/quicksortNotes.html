{% extends 'base.html' %}

{% block title %}Quicksort{% endblock %}

{% block content %}
<h1>Divide & Conquer Algorithm: Quicksort</h1>
<p>Quicksort is a sorting algorithm and much faster than selection sort.</p>

<h2>Understanding Divide & Conquer</h2>
<p>Divide & Conquer algorithms are <strong>recursive</strong>. To solve a problem using this method:</p>
<ol>
  <li>Figure out the base case (the simplest possible case).</li>
  <li>Divide or decrease the problem until it becomes the base case.</li>
</ol>
<p>With every recursive call, the problem is reduced further.</p>

<h3>Key Notes:</h3>
<ul>
  <li>Recursion keeps track of the state.</li>
  <li>When using recursion with an array, the base case is often an empty array or an array with one element.</li>
  <li>Functional programming languages like Haskell use recursion instead of loops.</li>
</ul>

<pre>
sum [] = 0
sum (x:xs) = x + (sum xs)
</pre>

<h3>Exercises:</h3>
<p>1. Write the sum function in Python:</p>
<pre>
def sum(lst):
    if lst == []:
        return 0
    return lst[0] + sum(lst[1:])
</pre>

<p>2. Write a recursive function to count the number of items in a list:</p>
<pre>
def count(lst):
    if lst == []:
        return 0
    return 1 + count(lst[1:])
</pre>

<p>3. Find the maximum number in a list:</p>
<pre>
def max(lst):
    if len(lst) == 2:
        return lst[0] if lst[0] > lst[1] else lst[1]
    sub_max = max(lst[1:])
    return lst[0] if lst[0] > sub_max else sub_max
</pre>

<h2>Binary Search & Divide & Conquer</h2>
<p>Binary search is another example of a Divide & Conquer algorithm:</p>
<ul>
  <li>Base case: An array with one item. If it matches the target, return it.</li>
  <li>Recursive case: Split the array, discard one half, and apply binary search to the other half.</li>
</ul>

<hr>

<h2>Quicksort</h2>
<p>Quicksort is a faster sorting algorithm compared to selection sort. It also uses Divide & Conquer.</p>

<h3>Example:</h3>
<pre>
[33, 15, 10]
</pre>
<ul>
  <li>Pick a pivot (e.g., 33).</li>
  <li>Partition the array into two sub-arrays: one with elements smaller than the pivot and one with elements greater than the pivot.</li>
</ul>
<p>Partition result:</p>
<pre>
[15, 10] + [33] + [] = [10, 15, 33]
</pre>

<h3>Quicksort Code:</h3>
<pre>
def quicksort(array):
    if len(array) < 2:
        return array
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot]
        greater = [i for i in array[1:] if i > pivot]
        return quicksort(less) + [pivot] + quicksort(greater)

print(quicksort([10, 5, 2, 3]))
</pre>

<hr>

<h2>Big O Notation</h2>
<p>Quicksort speed depends on the pivot choice:</p>

<table border="1">
  <tr>
    <th>Algorithm</th>
    <th>Best Case</th>
    <th>Worst Case</th>
  </tr>
  <tr>
    <td>Binary Search</td>
    <td>O(log n)</td>
    <td>-</td>
  </tr>
  <tr>
    <td>Simple Search</td>
    <td>O(n)</td>
    <td>-</td>
  </tr>
  <tr>
    <td>Quicksort</td>
    <td>O(n log n)</td>
    <td>O(nÂ²)</td>
  </tr>
</table>

<h3>Comparison to Merge Sort:</h3>
<p>Quicksort generally has a smaller constant than Merge Sort, making it faster in practice.</p>

<hr>

<h2>Recap</h2>
<ul>
  <li>Divide & Conquer breaks problems into smaller subproblems until the base case is reached.</li>
  <li>Quicksort is faster in practice because it typically hits the average case.</li>
  <li>The average runtime of Quicksort is O(n log n).</li>
</ul>
{% endblock %}
